/*
 * YNAB API Endpoints
 *
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.ynab.com
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_transaction`]
#[derive(Clone, Debug)]
pub struct CreateTransactionParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The transaction or transactions to create.  To create a single transaction you can specify a value for the `transaction` object and to create multiple transactions you can specify an array of `transactions`.  It is expected that you will only provide a value for one of these objects.
    pub data: crate::models::PostTransactionsWrapper
}

/// struct for passing parameters to the method [`delete_transaction`]
#[derive(Clone, Debug)]
pub struct DeleteTransactionParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The id of the transaction
    pub transaction_id: String
}

/// struct for passing parameters to the method [`get_transaction_by_id`]
#[derive(Clone, Debug)]
pub struct GetTransactionByIdParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The id of the transaction
    pub transaction_id: String
}

/// struct for passing parameters to the method [`get_transactions`]
#[derive(Clone, Debug)]
pub struct GetTransactionsParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    pub since_date: Option<String>,
    /// If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    pub r#type: Option<String>,
    /// The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    pub last_knowledge_of_server: Option<i64>
}

/// struct for passing parameters to the method [`get_transactions_by_account`]
#[derive(Clone, Debug)]
pub struct GetTransactionsByAccountParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The id of the account
    pub account_id: String,
    /// If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    pub since_date: Option<String>,
    /// If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    pub r#type: Option<String>,
    /// The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    pub last_knowledge_of_server: Option<i64>
}

/// struct for passing parameters to the method [`get_transactions_by_category`]
#[derive(Clone, Debug)]
pub struct GetTransactionsByCategoryParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The id of the category
    pub category_id: String,
    /// If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    pub since_date: Option<String>,
    /// If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    pub r#type: Option<String>,
    /// The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    pub last_knowledge_of_server: Option<i64>
}

/// struct for passing parameters to the method [`get_transactions_by_payee`]
#[derive(Clone, Debug)]
pub struct GetTransactionsByPayeeParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The id of the payee
    pub payee_id: String,
    /// If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
    pub since_date: Option<String>,
    /// If specified, only transactions of the specified type will be included. \"uncategorized\" and \"unapproved\" are currently supported.
    pub r#type: Option<String>,
    /// The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
    pub last_knowledge_of_server: Option<i64>
}

/// struct for passing parameters to the method [`import_transactions`]
#[derive(Clone, Debug)]
pub struct ImportTransactionsParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String
}

/// struct for passing parameters to the method [`update_transaction`]
#[derive(Clone, Debug)]
pub struct UpdateTransactionParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The id of the transaction
    pub transaction_id: String,
    /// The transaction to update
    pub data: crate::models::PutTransactionWrapper
}

/// struct for passing parameters to the method [`update_transactions`]
#[derive(Clone, Debug)]
pub struct UpdateTransactionsParams {
    /// The id of the budget. \"last-used\" can be used to specify the last used budget and \"default\" can be used if default budget selection is enabled (see: https://api.ynab.com/#oauth-default-budget).
    pub budget_id: String,
    /// The transactions to update. Each transaction must have either an `id` or `import_id` specified. If `id` is specified as null an `import_id` value can be provided which will allow transaction(s) to be updated by their `import_id`. If an `id` is specified, it will always be used for lookup.
    pub data: crate::models::PatchTransactionsWrapper
}


/// struct for typed errors of method [`create_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTransactionError {
    Status400(crate::models::ErrorResponse),
    Status409(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTransactionError {
    Status404(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionByIdError {
    Status404(crate::models::ErrorResponse),
    DefaultResponse(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionsError {
    Status400(crate::models::ErrorResponse),
    Status404(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transactions_by_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionsByAccountError {
    Status404(crate::models::ErrorResponse),
    DefaultResponse(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transactions_by_category`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionsByCategoryError {
    Status404(crate::models::ErrorResponse),
    DefaultResponse(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transactions_by_payee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionsByPayeeError {
    Status404(crate::models::ErrorResponse),
    DefaultResponse(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportTransactionsError {
    Status400(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTransactionError {
    Status400(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTransactionsError {
    Status400(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Creates a single transaction or multiple transactions.  If you provide a body containing a `transaction` object, a single transaction will be created and if you provide a body containing a `transactions` array, multiple transactions will be created.  Scheduled transactions cannot be created on this endpoint.
pub async fn create_transaction(configuration: &configuration::Configuration, params: CreateTransactionParams) -> Result<crate::models::SaveTransactionsResponse, Error<CreateTransactionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateTransactionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a transaction
pub async fn delete_transaction(configuration: &configuration::Configuration, params: DeleteTransactionParams) -> Result<crate::models::TransactionResponse, Error<DeleteTransactionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let transaction_id = params.transaction_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions/{transaction_id}", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id), transaction_id=crate::apis::urlencode(transaction_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteTransactionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single transaction
pub async fn get_transaction_by_id(configuration: &configuration::Configuration, params: GetTransactionByIdParams) -> Result<crate::models::TransactionResponse, Error<GetTransactionByIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let transaction_id = params.transaction_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions/{transaction_id}", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id), transaction_id=crate::apis::urlencode(transaction_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTransactionByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns budget transactions
pub async fn get_transactions(configuration: &configuration::Configuration, params: GetTransactionsParams) -> Result<crate::models::TransactionsResponse, Error<GetTransactionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let since_date = params.since_date;
    let r#type = params.r#type;
    let last_knowledge_of_server = params.last_knowledge_of_server;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = since_date {
        local_var_req_builder = local_var_req_builder.query(&[("since_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_knowledge_of_server {
        local_var_req_builder = local_var_req_builder.query(&[("last_knowledge_of_server", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all transactions for a specified account
pub async fn get_transactions_by_account(configuration: &configuration::Configuration, params: GetTransactionsByAccountParams) -> Result<crate::models::TransactionsResponse, Error<GetTransactionsByAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let account_id = params.account_id;
    let since_date = params.since_date;
    let r#type = params.r#type;
    let last_knowledge_of_server = params.last_knowledge_of_server;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/accounts/{account_id}/transactions", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id), account_id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = since_date {
        local_var_req_builder = local_var_req_builder.query(&[("since_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_knowledge_of_server {
        local_var_req_builder = local_var_req_builder.query(&[("last_knowledge_of_server", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTransactionsByAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all transactions for a specified category
pub async fn get_transactions_by_category(configuration: &configuration::Configuration, params: GetTransactionsByCategoryParams) -> Result<crate::models::HybridTransactionsResponse, Error<GetTransactionsByCategoryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let category_id = params.category_id;
    let since_date = params.since_date;
    let r#type = params.r#type;
    let last_knowledge_of_server = params.last_knowledge_of_server;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/categories/{category_id}/transactions", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id), category_id=crate::apis::urlencode(category_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = since_date {
        local_var_req_builder = local_var_req_builder.query(&[("since_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_knowledge_of_server {
        local_var_req_builder = local_var_req_builder.query(&[("last_knowledge_of_server", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTransactionsByCategoryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all transactions for a specified payee
pub async fn get_transactions_by_payee(configuration: &configuration::Configuration, params: GetTransactionsByPayeeParams) -> Result<crate::models::HybridTransactionsResponse, Error<GetTransactionsByPayeeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let payee_id = params.payee_id;
    let since_date = params.since_date;
    let r#type = params.r#type;
    let last_knowledge_of_server = params.last_knowledge_of_server;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/payees/{payee_id}/transactions", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id), payee_id=crate::apis::urlencode(payee_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = since_date {
        local_var_req_builder = local_var_req_builder.query(&[("since_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_knowledge_of_server {
        local_var_req_builder = local_var_req_builder.query(&[("last_knowledge_of_server", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTransactionsByPayeeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Imports available transactions on all linked accounts for the given budget.  Linked accounts allow transactions to be imported directly from a specified financial institution and this endpoint initiates that import.  Sending a request to this endpoint is the equivalent of clicking \"Import\" on each account in the web application or tapping the \"New Transactions\" banner in the mobile applications.  The response for this endpoint contains the transaction ids that have been imported.
pub async fn import_transactions(configuration: &configuration::Configuration, params: ImportTransactionsParams) -> Result<crate::models::TransactionsImportResponse, Error<ImportTransactionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions/import", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ImportTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a single transaction
pub async fn update_transaction(configuration: &configuration::Configuration, params: UpdateTransactionParams) -> Result<crate::models::TransactionResponse, Error<UpdateTransactionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let transaction_id = params.transaction_id;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions/{transaction_id}", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id), transaction_id=crate::apis::urlencode(transaction_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateTransactionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates multiple transactions, by `id` or `import_id`.
pub async fn update_transactions(configuration: &configuration::Configuration, params: UpdateTransactionsParams) -> Result<crate::models::SaveTransactionsResponse, Error<UpdateTransactionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let budget_id = params.budget_id;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/budgets/{budget_id}/transactions", local_var_configuration.base_path, budget_id=crate::apis::urlencode(budget_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

