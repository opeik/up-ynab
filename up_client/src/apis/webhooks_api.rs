/*
 * Up API
 *
 * The Up API gives you programmatic access to your balances and transaction data. You can request past transactions or set up webhooks to receive real-time events when new transactions hit your account. It’s new, it’s exciting and it’s just the beginning. 
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`webhooks_get`]
#[derive(Clone, Debug)]
pub struct WebhooksGetParams {
    /// The number of records to return in each page. 
    pub page_left_square_bracket_size_right_square_bracket: Option<i32>
}

/// struct for passing parameters to the method [`webhooks_id_delete`]
#[derive(Clone, Debug)]
pub struct WebhooksIdDeleteParams {
    /// The unique identifier for the webhook. 
    pub id: String
}

/// struct for passing parameters to the method [`webhooks_id_get`]
#[derive(Clone, Debug)]
pub struct WebhooksIdGetParams {
    /// The unique identifier for the webhook. 
    pub id: String
}

/// struct for passing parameters to the method [`webhooks_post`]
#[derive(Clone, Debug)]
pub struct WebhooksPostParams {
    pub create_webhook_request: Option<crate::models::CreateWebhookRequest>
}

/// struct for passing parameters to the method [`webhooks_webhook_id_logs_get`]
#[derive(Clone, Debug)]
pub struct WebhooksWebhookIdLogsGetParams {
    /// The unique identifier for the webhook. 
    pub webhook_id: String,
    /// The number of records to return in each page. 
    pub page_left_square_bracket_size_right_square_bracket: Option<i32>
}

/// struct for passing parameters to the method [`webhooks_webhook_id_ping_post`]
#[derive(Clone, Debug)]
pub struct WebhooksWebhookIdPingPostParams {
    /// The unique identifier for the webhook. 
    pub webhook_id: String
}


/// struct for typed errors of method [`webhooks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_webhook_id_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksWebhookIdLogsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_webhook_id_ping_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksWebhookIdPingPostError {
    UnknownValue(serde_json::Value),
}


/// Retrieve a list of configured webhooks. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered oldest first to newest last. 
pub async fn webhooks_get(configuration: &configuration::Configuration, params: WebhooksGetParams) -> Result<crate::models::ListWebhooksResponse, Error<WebhooksGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_left_square_bracket_size_right_square_bracket = params.page_left_square_bracket_size_right_square_bracket;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/webhooks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_left_square_bracket_size_right_square_bracket {
        local_var_req_builder = local_var_req_builder.query(&[("page[size]", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WebhooksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific webhook by providing its unique identifier. Once deleted, webhook events will no longer be sent to the configured URL. 
pub async fn webhooks_id_delete(configuration: &configuration::Configuration, params: WebhooksIdDeleteParams) -> Result<(), Error<WebhooksIdDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/webhooks/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<WebhooksIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific webhook by providing its unique identifier. 
pub async fn webhooks_id_get(configuration: &configuration::Configuration, params: WebhooksIdGetParams) -> Result<crate::models::GetWebhookResponse, Error<WebhooksIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/webhooks/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WebhooksIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new webhook with a given URL. The URL will receive webhook events as JSON-encoded `POST` requests. The URL must respond with a HTTP `200` status on success.  There is currently a limit of 10 webhooks at any given time. Once this limit is reached, existing webhooks will need to be deleted before new webhooks can be created.  Event delivery is retried with exponential backoff if the URL is unreachable or it does not respond with a `200` status. The response includes a `secretKey` attribute, which is used to sign requests sent to the webhook URL. It will not be returned from any other endpoints within the Up API. If the `secretKey` is lost, simply create a new webhook with the same URL, capture its `secretKey` and then delete the original webhook. See [Handling webhook events](#callback_post_webhookURL) for details on how to process webhook events.  It is probably a good idea to test the webhook by [sending it a `PING` event](#post_webhooks_webhookId_ping) after creating it. 
pub async fn webhooks_post(configuration: &configuration::Configuration, params: WebhooksPostParams) -> Result<crate::models::CreateWebhookResponse, Error<WebhooksPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_webhook_request = params.create_webhook_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/webhooks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_webhook_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WebhooksPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of delivery logs for a webhook by providing its unique identifier. This is useful for analysis and debugging purposes. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered newest first to oldest last. Logs may be automatically purged after a period of time. 
pub async fn webhooks_webhook_id_logs_get(configuration: &configuration::Configuration, params: WebhooksWebhookIdLogsGetParams) -> Result<crate::models::ListWebhookDeliveryLogsResponse, Error<WebhooksWebhookIdLogsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let webhook_id = params.webhook_id;
    let page_left_square_bracket_size_right_square_bracket = params.page_left_square_bracket_size_right_square_bracket;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/webhooks/{webhookId}/logs", local_var_configuration.base_path, webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_left_square_bracket_size_right_square_bracket {
        local_var_req_builder = local_var_req_builder.query(&[("page[size]", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WebhooksWebhookIdLogsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send a `PING` event to a webhook by providing its unique identifier. This is useful for testing and debugging purposes. The event is delivered asynchronously and its data is returned in the response to this request. 
pub async fn webhooks_webhook_id_ping_post(configuration: &configuration::Configuration, params: WebhooksWebhookIdPingPostParams) -> Result<crate::models::WebhookEventCallback, Error<WebhooksWebhookIdPingPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let webhook_id = params.webhook_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/webhooks/{webhookId}/ping", local_var_configuration.base_path, webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<WebhooksWebhookIdPingPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

